module.exports.config = {
    name: "thoitiet",
    version: "1.0.2",
    hasPermssion: 0,
    credits: "D-Jukie convert t·ª´ Goat(TatsuYTB)",
    description: "Xem th·ªùi ti·∫øt trong 5 ng√†y",
    commandCategory: "Ti·ªán √≠ch",
    usages: "[location]",
    cooldowns: 15
};

module.exports.run = async function({ api, event, args }) {
    const axios = require("axios");
    const moment = require("moment-timezone");
    const Canvas = require("canvas");
    const fs = require("fs-extra");
    const svg2img = require("svg2img");

    const apikey = "d7e795ae6a0d44aaa8abb1a0a7ac19e4";
    const area = args.join(" ");
    console.log("üìå Nh·∫≠n y√™u c·∫ßu xem th·ªùi ti·∫øt cho:", area);

    if (!area) return api.sendMessage(`Vui l√≤ng nh·∫≠p ƒë·ªãa ƒëi·ªÉm!`, event.threadID, event.messageID);

    let areaKey, location = {}, dataWeather;

    // T·∫£i ·∫£nh n·ªÅn n·∫øu ch∆∞a c√≥
    if (!fs.existsSync(__dirname + '/cache/bgweather.jpg')) {
        console.log("‚¨áÔ∏è T·∫£i ·∫£nh n·ªÅn...");
        let getbg = (await axios.get(`https://i.imgur.com/1Rx88Te.jpg`, { responseType: "arraybuffer" })).data;
        fs.writeFileSync(__dirname + "/cache/bgweather.jpg", Buffer.from(getbg, "utf-8"));
    }

    // T·∫£i font n·∫øu ch∆∞a c√≥
    if (!fs.existsSync(__dirname + "/cache/Play-Bold.ttf")) {
        console.log("‚¨áÔ∏è T·∫£i font ch·ªØ...");
        let getfont = (await axios.get("https://drive.google.com/u/0/uc?id=1uni8AiYk7prdrC7hgAmezaGTMH5R8gW8&export=download", { responseType: "arraybuffer" })).data;
        fs.writeFileSync(__dirname + "/cache/Play-Bold.ttf", Buffer.from(getfont, "utf-8"));
    }

    // ===> T√¨m ƒë·ªãa ƒëi·ªÉm
    try {
        console.log("üîç ƒêang t√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm...");
        const resLocation = await axios.get(`https://api.accuweather.com/locations/v1/cities/search.json?q=${encodeURIComponent(area)}&apikey=${apikey}&language=vi-vn`);
        console.log("üì¶ K·∫øt qu·∫£ t√¨m ki·∫øm:", JSON.stringify(resLocation.data, null, 2));

        if (resLocation.data.length === 0) {
            console.log("‚ùå Kh√¥ng c√≥ k·∫øt qu·∫£ tr·∫£ v·ªÅ.");
            return api.sendMessage(`Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm n√†y!`, event.threadID, event.messageID);
        }

        const data = resLocation.data[0];
        areaKey = data.Key;
        location = {
            latitude: data.GeoPosition.Latitude,
            longitude: data.GeoPosition.Longitude
        };
        console.log("‚úÖ T√¨m th·∫•y:", data.LocalizedName, "| Key:", areaKey);
    } catch (err) {
        console.error("‚ùå L·ªói t√¨m ƒë·ªãa ƒëi·ªÉm:", err.response?.data || err.message);
        return api.sendMessage(`ƒê√£ c√≥ l·ªói x·∫£y ra khi t√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm!`, event.threadID, event.messageID);
    }

    // ===> L·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt
    try {
        console.log("üå§Ô∏è L·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt...");
        const resWeather = await axios.get(`http://api.accuweather.com/forecasts/v1/daily/10day/${areaKey}?apikey=${apikey}&details=true&language=vi`);
        dataWeather = resWeather.data;
        console.log("‚úÖ D·ªØ li·ªáu th·ªùi ti·∫øt l·∫•y ƒë∆∞·ª£c:", JSON.stringify(dataWeather, null, 2));
    } catch (err) {
        console.error("‚ùå L·ªói khi l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt:", err.response?.data || err.message);
        return api.sendMessage(`ƒê√£ c√≥ l·ªói x·∫£y ra khi l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt!`, event.threadID, event.messageID);
    }

    function convertFtoC(F) { return Math.floor((F - 32) / 1.8); }
    function formatHours(hours) { return moment(hours).tz("Asia/Ho_Chi_Minh").format("HH[h]mm[p]"); }
    function translateWindDirection(direction) {
        const directions = {
            "B": "B·∫Øc", "BB": "B·∫Øc ƒê√¥ng B·∫Øc", "ƒêB": "ƒê√¥ng B·∫Øc", "ƒê": "ƒê√¥ng",
            "ƒêN": "ƒê√¥ng ƒê√¥ng Nam", "N": "Nam", "NTN": "Nam T√¢y Nam",
            "T": "T√¢y", "TT": "T√¢y T√¢y B·∫Øc", "TNB": "T√¢y Nam"
        };
        return directions[direction] || direction;
    }

    const today = dataWeather.DailyForecasts[0];
    const windDirection = translateWindDirection(today.Day.Wind.Direction.Localized);

    let msg = `D·ª± b√°o th·ªùi ti·∫øt:\n${dataWeather.Headline.Text}` +
        `\nüå° Nhi·ªát ƒë·ªô: ${convertFtoC(today.Temperature.Minimum.Value)}¬∞C - ${convertFtoC(today.Temperature.Maximum.Value)}¬∞C` +
        `\nüå° C·∫£m nh·∫≠n: ${convertFtoC(today.RealFeelTemperature.Minimum.Value)}¬∞C - ${convertFtoC(today.RealFeelTemperature.Maximum.Value)}¬∞C` +
        `\nüåÖ M·∫∑t tr·ªùi m·ªçc: ${formatHours(today.Sun.Rise)}` +
        `\nüåÑ M·∫∑t tr·ªùi l·∫∑n: ${formatHours(today.Sun.Set)}` +
        `\n‚òÅÔ∏è M·∫≠t ƒë·ªô m√¢y: ${today.Day.CloudCover}%` +
        `\nüí® Gi√≥: ${windDirection} - ${today.Day.Wind.Speed.Value} km/h` +
        `\nüåßÔ∏è M∆∞a: ${today.Day.PrecipitationProbability}% | ‚ö° D√¥ng: ${today.Day.ThunderstormProbability}%` +
        `\nüîÜ UV: ${today.AirAndPollen[5].Value}` +
        `\nüíß ·∫®m: Min ${today.Day.RelativeHumidity.Minimum}%, Max ${today.Day.RelativeHumidity.Maximum}%, TB ${today.Day.RelativeHumidity.Average}%` +
        `\nüå¶Ô∏è M∆∞a trong ng√†y: ${today.Day.HoursOfPrecipitation} gi·ªù` +
        `\nüî• B·ªëc h∆°i: ${today.Day.Evapotranspiration.Value} in` +
        `\nüîÖ B·ª©c x·∫°: ${today.Day.SolarIrradiance.Value} W/m¬≤` +
        `\nüíß Nhi·ªát ƒë·ªô ∆∞·ªõt: ${convertFtoC(today.Day.WetBulbTemperature.Minimum.Value)}¬∞C - ${convertFtoC(today.Day.WetBulbTemperature.Maximum.Value)}¬∞C`;

    console.log("üì® Tin nh·∫Øn chu·∫©n b·ªã g·ª≠i:\n" + msg);

    Canvas.registerFont(__dirname + "/cache/Play-Bold.ttf", { family: "Play-Bold" });
    const bg = await Canvas.loadImage(__dirname + "/cache/bgweather.jpg");
    const canvas = Canvas.createCanvas(bg.width, bg.height);
    const ctx = canvas.getContext("2d");
    ctx.drawImage(bg, 0, 0);

    // V·∫Ω d·ª± b√°o 7 ng√†y t·ªõi
    const days = dataWeather.DailyForecasts.slice(0, 7);
    ctx.fillStyle = "#ffffff";
    ctx.font = "22px Play-Bold";
    let X = 100;

    for (const item of days) {
        try {
            const iconURL = `http://vortex.accuweather.com/adc2010/images/slate/icons/${item.Day.Icon}.svg`;
            const iconBuffer = (await axios.get(iconURL, { responseType: "arraybuffer" })).data;
            svg2img(iconBuffer, { width: 80, height: 80 }, (err, buffer) => {
                if (!err) {
                    const img = new Canvas.Image();
                    img.src = buffer;
                    ctx.drawImage(img, X, 210, 80, 80);
                }
            });

            ctx.fillText(`${convertFtoC(item.Temperature.Maximum.Value)}¬∞C`, X, 366);
            ctx.fillText(`${convertFtoC(item.Temperature.Minimum.Value)}¬∞C`, X, 445);
            ctx.fillText(moment(item.Date).format("DD"), X + 20, 140);
            X += 135;
        } catch (e) {
            console.log("‚ö†Ô∏è L·ªói khi v·∫Ω icon ng√†y:", e.message);
        }
    }

    const imgPath = __dirname + "/cache/weather.jpg";
    fs.writeFileSync(imgPath, canvas.toBuffer());

    try {
        console.log("üì§ G·ª≠i ·∫£nh th·ªùi ti·∫øt...");
        return api.sendMessage({
            body: msg,
            attachment: fs.createReadStream(imgPath)
        }, event.threadID, () => fs.unlinkSync(imgPath), event.messageID);
    } catch (err) {
        console.error("‚ùå L·ªói khi g·ª≠i tin nh·∫Øn:", err);
    }
};
